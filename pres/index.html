<!DOCTYPE html>
<html>

<head>
    <title>IPS / PSA</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css">
    <link rel="stylesheet" type="text/css" href="core/css/animate.css">
    <link rel="stylesheet" type="text/css" href="core/css/cinescript.css">
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css">
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css">
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css">
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css">
    <link rel="stylesheet" type="text/css" href="core/css/katex.css">
</head>

<body>
    <textarea id="source" readonly>

class: middle

# Projet PRSA
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

I. [Introduction au projet](index.html#)

1. Présentation du problème

II. [Base de donnée](index.html#)

1. Structure de la base de donnée
2. Utilisation de la base de donnée
3. Exemple d'expérience

III. [Field generator](index.html#)

1. Fichier d'entrée JSON
2. Fonctionnement du Field generator

IV. [Solveur Implémentation](index.html#)
    
1. Matrices complexes
2. Implémentation des méthodes de résolution
3. Bindings python

V. [Post Processor](index.html#8)

1. Idée d'implémentation

---
class: middle
# I - Introduction au projet - Présentation du problème
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

### Problématique
Le projet consiste à réaliser un solveur d'équations de Schrödinger en 2D pour simuler le comportement d'une onde quantique dans un potentiel donné.

Le projet doit implémenter les programmes FTCS, BTCS et CTCS.

---
class: middle
# II - Base de donnée - Structure de la base de donnée
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

Nous avons une base de donnée "results" qui stoque nos expérences.

Chaque collection correspond à une expérience dans la base de donnée.

<iframe src="./images/database_finale.png" width="100%" height="470px"></iframe>

---
class: middle
# II - Base de donnée - Interaction avec la base de donnée
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

```python3
def AlreadyExist(collectionName):
    for elt in db.list_collection_names():
        if elt == collectionName:
            return True
    return False


def AlreadyExistHash(hashCode):
    for elt in db.list_collection_names():
        exp = db[elt]
        for data in exp.find({"Init": True}):
            if data["Json_Hash"] == hashCode:
                return True
    return False


def DeleteCollection(collectionName):
    try:
        if AlreadyExist(collectionName):
            db.drop_collection(collectionName)
        else:
            print(collectionName + " doesn't exist, cannot delete a non existing collection")
    
    except pymongo.errors.OperationFailure as e:
        print("ERROR: %s" % (e))
```

---
class: middle
# II - Base de donnée - Insertion dans la base de donnée
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

```python3
def CreateExperience(experienceName, jsonFile, jsonHash, potential):
    try:
        experience = db[experienceName]

        potentialDB = bson.binary.Binary(pickle.dumps(potential, protocol = 2))

        data = { "Init": True, "Json_File": jsonFile, "Json_Hash": jsonHash, "Potential": potentialDB }
        experience.insert_one(data)

    except pymongo.errors.OperationFailure as e:
        print("ERROR: %s" % (e))


def InsertMatrix(experienceName, time, psiRe, psiIm):
    try:
        if AlreadyExist(experienceName):
            experience = db[experienceName]

            psiReDB = bson.binary.Binary(pickle.dumps(psiRe, protocol = 2))
            psiImDB = bson.binary.Binary(pickle.dumps(psiIm, protocol = 2))

            data = { "Init": False, "Time": time, "Psi_Real": psiReDB, "Psi_Imaginary": psiImDB }
            experience.insert_one(data)
        else:
            print(experienceName + " doesn't exist, create it before inserting data")

    except pymongo.errors.OperationFailure as e:
        print("ERROR: %s" % (e))
```

---
class: middle
# II - Base de donnée - Récupération dans la base de donnée
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

```python3
def GetPotential(experienceName):
    try:
        if AlreadyExist(experienceName):
            experience = db[experienceName]

            for data in experience.find({"Init": True}):
                matdata = data["Potential"]
                mat = pickle.loads(matdata)

            return mat
        else:
            print(experienceName + " doesn't exist, cannot get the potential of a non existing experience")
    except pymongo.errors.OperationFailure as e:
        print("ERROR: %s" % (e))


def GetJsonFile(experienceName):
    try:
        if AlreadyExist(experienceName):
            experience = db[experienceName]

            for data in experience.find({"Init": True}):
                filedata = data["Json_File"]

            return filedata
        else:
            print(experienceName + " doesn't exist, cannot get the Json file of a non existing experience")

    except pymongo.errors.OperationFailure as e:
        print("ERROR: %s" % (e))

```

---
class: middle
# II - Base de donnée - Récupération dans la base de donnée
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

```python3
def GetLastState(experienceName):
    try:
        if AlreadyExist(experienceName):
            experience = db[experienceName]

            lastTime = -1
            for data in experience.find({"Init": False}):
                if data["Time"] > lastTime:
                    lastTime = data["Time"]
                    psiReData = data["Psi_Real"]
                    psiRe = pickle.loads(psiReData)
                    psiImData = data["Psi_Imaginary"]
                    psiIm = pickle.loads(psiImData)

            return (lastTime, psiRe, psiIm)
        else:
            print(experienceName + " doesn't exist, cannot get the last state of a non existing experience")
    except pymongo.errors.OperationFailure as e:
        print("ERROR: %s" % (e))


def GetStates(experienceName):
    try:
        if AlreadyExist(experienceName):
            experience = db[experienceName]

            stateList = []
            for data in experience.find({"Init": False}):
                time = data["Time"]
                psiReData = data["Psi_Real"]
                psiRe = pickle.loads(psiReData)
                psiImData = data["Psi_Imaginary"]
                psiIm = pickle.loads(psiImData)
                stateList.append((time, psiRe, psiIm))

            return stateList
        else:
            print(experienceName + " doesn't exist, cannot get the list of states of a non existing experience")
    except pymongo.errors.OperationFailure as e:
        print("ERROR: %s" % (e))
```

---
class: middle
# II - Base de donnée - Exemple d'expérience
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

```python3
def test_pres():
    DeleteCollection('Présentation')
    CreateExperience('Présentation', 'presentation.json', 'nosj.noitatneserp', np.eye(3))
    InsertMatrix('Présentation', 0, np.eye(3), np.eye(3))
    InsertMatrix('Présentation', 1, 2 * np.eye(3), 2 * np.eye(3))
    InsertMatrix('Présentation', 2, 3 * np.eye(3), 3 * np.eye(3))
    print(db.list_collection_names())
    print(GetJsonFile('Présentation'))
    print(GetPotential('Présentation'))
    print(GetStates('Présentation'))
```

```shell
['Présentation']
presentation.json
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
[(0, array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]]), 
    array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])),
 (1, array([[2., 0., 0.],
       [0., 2., 0.],
       [0., 0., 2.]]),
    array([[2., 0., 0.],
       [0., 2., 0.],
       [0., 0., 2.]])),
 (2, array([[3., 0., 0.],
       [0., 3., 0.],
       [0., 0., 3.]]),
    array([[3., 0., 0.],
       [0., 3., 0.],
       [0., 0., 3.]]))]

```

---
class: middle
# III - Field generator - Fichier d'entrée JSON
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

L'utilisateur entre dans le fichier JSON les paramètres de l'expérience qu'il souhaite réaliser.

#### Dans consts.JSON :
```json
{
    "name": "experience_name",
    "constantes": {
        "n_x": 101,
        "n_y": 101,
        "x_min": -10,
        "x_max": 10,
        "y_min": -10,
        "y_max": 10,
        "h": 1,
        "m": 1,
        "w": 1,
        "k_x": 0,
        "k_y": 0
    },
    "user parameters": {
        "psi": {
            "type": 0,
            "nb": 1,
            "2DH0_nx": 2,
            "2DH0_ny": 0,
            "x0": 0,
            "y0": 0
        },
        "V": "Harmonic",
        "image_V": "/path/to/image.png",
        "method": "FTCS",
        "dt": "default",
        "t_max": 10
    }
}
```

---
class: middle
# III - Field generator - Fonctionnement du main
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

## Fonctionnement global du field_generator :

#### Dans main.py

On calcule d'abord le potentiel, la fonction d'onde psi et le hash du  fichier JSON associé à l'expérience.

Puis on vérifie si le nom de l'expérience donné par l'utilisateur n'existe pas déja dans la base de donnée.
Si le nom existe déjà, on vérifie si le hash du JSON de l'expérience associé est identique à celui proposé.
Si tel est le cas, on demande à l'utilisateur s'il souhaite écraser l'expérience ou non.

Puis, on vérifie si le nouveau Hash n'existe pas déjà dans la base de donnée avant de créer une nouvelle entrée dedans.

```python
def main():
    global Vmat, psi0Re, psi0Im, exp_name, data, hash
    # Calculate the potential according to the V value :
    Vmat = calcV()

    # Calculate the wave function according to the psi value :
    psi0Re, psi0Im = calcPsi()

    # Calculate the hash of the experiment
    hash = calcJSONHash()
```

---
class: middle
# III - Field generator - Différents Psi_0 calculés
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

#### Dans main.py

```python
    val = True
        if db.AlreadyExist(exp_name):
            print("An experiment with the same name already exists.")
            if db.AlreadyExistHash(hash):
                print("An experiment with the same name and the same hash already exists.")
                print("Will use the results of this experiment to continue.")
                val = False
            while val:
                u_input = input("Do you want to overwrite it ? (y/N) : ")
                if u_input == "y":
                    db.DeleteCollection(exp_name)
                    val = False
                elif u_input == "N":
                    exp_name = input("Please choose a new name for the experiment: ")
                    val = False
                elif u_input == "exit":
                    exit(1)
                else:
                    print("Invalid input, please choose y or n")

    if not db.AlreadyExistHash(hash):
        file = "../consts.JSON"
        with open(file, "r", encoding="utf-8") as f:
            data = json.load(f)
        db.CreateExperience(exp_name, data, hash, Vmat)
        db.InsertMatrix(exp_name, 0, psi0Re, psi0Im)
        print("Experience initialized")
```

---
class: middle
# IV - Solveur - Matrices complexes
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

#### Dans complex_mat.h
```cpp
typedef struct complex_mat
{
  mat re;
  mat im;
}complex_mat;
```

#### Dans complex_mat.cpp
```cpp
complex_mat init_c_mat(uword n, uword m)
{
  complex_mat M;
  M.re.zeros(n, m);
  M.im.zeros(n, m);
  return M;
}

ComplexMat::ComplexMat(mat re_val, mat im_val)
{
  complex_mat M;
  M.re = re_val;
  M.im = im_val;
}
```

---
class: middle
# IV - Solveur - Implémentation des méthodes de résolution
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

#### Dans solver.cpp
```cpp
complex_mat Solver::FTCS_derivation(complex_mat psi_t)
{
  complex_mat psi_t_dt = init_c_mat(nx, ny);

  double dt = dt_vals[0];
  int dx = (x_max - x_min) / nx;
  int dy = (y_max - y_min) / ny;

  for(uword i = 1; i < nx-1; ++i)
  {
    for(uword j = 1; j < ny-1; ++j)
    {
      double A = ((-1/h_bar)*V(i,j) - ((h_bar/m) * (1/dx*dx + 1/dy*dy)));
      double B = (h_bar/2*m);
      double psi_x_im = psi_t.im(i+1,j) + psi_t.im(i-1,j);
      double psi_y_im = psi_t.im(i,j+1) + psi_t.im(i,j-1);
      double psi_x_re = psi_t.re(i+1,j) + psi_t.re(i-1,j);
      double psi_y_re = psi_t.re(i,j+1) + psi_t.re(i,j-1);

      psi_t_dt.re(i,j) = psi_t.re(i,j) - dt * (A * psi_t.im(i,j) + B * ((1/dx*dx) * psi_x_im + (1/dy*dy) * psi_y_im));
      psi_t_dt.im(i,j) = psi_t.im(i,j) + dt * (A * psi_t.re(i,j) + B * ((1/dx*dx) * psi_x_re + (1/dy*dy) * psi_y_re));
    }
  }
  return psi_t_dt;
}
```

---
class: middle
# IV - Solveur - Résulats FCTS
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Gaussienne et potentiel harmonique
<video controls="yes" preload="auto" width="100%" height="500px" data-setup="{}" loop>
    <source src="videos/FTCS_video.mp4" type="video/webm" />
    </video>

---
class: middle
# IV - Solveur - Résulats BCTS
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Gaussienne et potentiel harmonique
<video controls="yes" preload="auto" width="100%" height="500px" data-setup="{}" loop>
    <source src="videos/BTCS_video.mp4" type="video/webm" />
    </video>

---
class: middle
# IV - Solveur - Bindings python
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

#### Dans solver.i
```cpp
%module solver
%{
#include "../include/solver.h"
#include "../include/complexmat.h"
%}
%include "../include/solver.h"
%include "../include/complexmat.h"

```
#### Dans setup.py
```cpp
from setuptools import setup, Extension

module1 = Extension('_solver', sources=['solver.i','../src/solver.cpp', '../src/complexmat.cpp'], swig_opts=["-c++"])

setup(name='package_solver',
      py_modules=['solver'],
      version='1.0',
      description="This package implements the solver's functions",
      ext_modules=[module1])

```

---
class: middle
# V - Post processor -
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

## Cette partie n'a pas encore été traitée.

Voici cependant nos axes de réflexions :

1. extractions des matrices d'une expérience dans la base de donnée

2. convertion de chaque matrice en image

3. création d'une vidéo à partir des images obtenues


    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/katex.min.js"></script>
    <script src="core/javascript/auto-render.min.js"></script>
    <script src="core/javascript/emojify.js"></script>
    <script src="core/javascript/mermaid.js"></script>
    <script src="core/javascript/term.js"></script>
    <script src="core/javascript/jquery-2.1.1.min.js"></script>
    <script src="core/javascript/extend-jquery.js"></script>
    <script src="core/javascript/cinescript.js"></script>
    <script src="core/javascript/gitgraph.js"></script>
    <script>

        // === Remark.js initialization ===
        var slideshow = remark.create({
            highlightStyle: 'monokai',
            countIncrementalSlides: false,
            highlightLines: false
        });

        // === Mermaid.js initialization ===
        mermaid.initialize({
            startOnLoad: false,
            cloneCssStyles: false,
            flowchart: {
                height: 50
            },
            sequenceDiagram: {
                width: 110,
                height: 30
            }
        });

        function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i = 0; i < diagrams.length; i++) {
                if (diagrams[i].offsetWidth > 0) {
                    mermaid.init(undefined, diagrams[i]);
                }
            }
        }

        slideshow.on('afterShowSlide', initMermaid);
        initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);


        // === Emojify.js initialization ===
        emojify.run();

        // === Cinescript initialization ===
        $(document).ready(init_cinescripts);

        renderMathInElement(document.body, {
            delimiters: [{ left: "$$", right: "$$", display: true }, {
                left: "\\(",
                right: "\\)",
                display: false
            }], ignoredTags: []
        });

    </script>
</body>

</html>