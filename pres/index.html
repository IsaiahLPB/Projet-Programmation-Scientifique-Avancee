<!DOCTYPE html>
<html>

<head>
    <title>IPS / PSA</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css">
    <link rel="stylesheet" type="text/css" href="core/css/animate.css">
    <link rel="stylesheet" type="text/css" href="core/css/cinescript.css">
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css">
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css">
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css">
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css">
    <link rel="stylesheet" type="text/css" href="core/css/katex.css">
</head>

<body>
    <textarea id="source" readonly>

class: middle

# Projet PRSA

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]


I. [Introduction au problème](index.html#2) 

    1.
    2.

II. [Résolution du problème](index.html#4)
    
    1. Résolution mathématique
    2. Présentation du solveur

III. [](index.html#8)

    1.
    2.

---
class: middle
# I - Introduction - Présentation du problème

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

- Densité locale d'un système nucléaire.
- L'objectif était de calculer la densité nucléaire local d'un système et d'effectuer un plot 2d et 3d des résultats.

---
class: middle
# I - Introduction - Polynomes d'Hermite et Laguerre

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

Pour calculer les polynômes d'Hermite, nous avons utilisé la définition récursive suivante :
`$$H_0(z) = 1$$`
`$$H_1(z) = 2z$$`
`$$\forall n\ge 1, H_{n+1}(z) = 2zH_n(z)-2nH_{n-1}(z).$$`

```cpp
void Poly::calcHermite(int n, arma::vec zVals)
{
    // Initialize the matrix for Hermite polynomials with double values
    hermiteMat = arma::mat(n + 1, zVals.n_elem, arma::fill::zeros);
    // Base cases for Hermite polynomials: H_0(z) = 1 and H_1(z) = 2z
    hermiteMat.row(0).ones();  // H_0(z) = 1
    if (n >= 1) {
        hermiteMat.row(1) = 2.0 * zVals.t();  // H_1(z) = 2z
    }
    // Recursive computation of Hermite polynomials H_n(z)
    for (int i = 2; i <= n; ++i) {
        hermiteMat.row(i) = 2.0 * zVals.t() % hermiteMat.row(i - 1) - 2.0 * (i - 1) * hermiteMat.row(i - 2);
    }
}

```
---
class: middle

# I - Introduction - Calcul des polynômes de Laguerre 

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

La formule récursive de calcul des polynômes de Laguerre est :
### 

`$$
\begin{aligned}
L^{m}_0(\eta)&=1\\
L^{m}_1(\eta)&=1+m-\eta\\
\forall (m, n) \in \mathbb{N}^{2}, n > 1, L^{m}_{n}(\eta)&=\left(2+\frac{m-1-\eta}{n}\right)L^{m}_{n-1}(\eta)-\left(1+\frac{m-1}{n}\right)L^{m}_{n-2}(\eta)
\end{aligned}
$$`

### Implémentation

```cpp
void Poly::calcLaguerre(int m_max, int n_max, arma::vec rVals)
{
    // Initialize a 3D cube to store Laguerre polynomial values
    laguerreCube = arma::cube(rVals.n_elem, n_max + 1, m_max + 1, arma::fill::zeros);
    for (int m = 0; m <= m_max; ++m)  // Loop up to and including m_max
    {
        arma::vec L_0 = arma::vec(rVals.n_elem, arma::fill::ones);  
        laguerreCube.slice(m).col(0) = L_0;
        if (n_max > 0)
        {   
            arma::vec L_1 = m + 1 - rVals;  
            laguerreCube.slice(m).col(1) = L_1;
            // Recurrence relation for n > 1
            for (int n = 2; n <= n_max; ++n)
            {   
                arma::vec L_n = ((2.0 * (n - 1) + m + 1 - rVals) % L_1 - (n + m - 1) * L_0) / n;
                laguerreCube.slice(m).col(n) = L_n;
                // Update L_0 and L_1 for the next iteration
                L_0 = L_1;
                L_1 = L_n;
            }
        }
    }
}

```
---
class: middle



# II - Implémentation - Exécution du programme

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

Notre programme se lance avec le script run.sh présent à la racine de notre projet.

On exécute le script suivant :
``` sh

#!/bin/bash

#make clean

echo "----------Compilation avec make du projet----------"
make

echo " "
echo "----------Execution du programme principal----------"
./bin/main

echo " "
echo "----------Execution de plot.py pour l'affichage----------"
python3 plot.py

echo " "
echo "----------Affichage de la denstité avec povray----------"
#povray +A0.0001 -W800 -H600 +P +Q11 src/visu.pov


```
---
class: middle

# II - Makefile

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

Le Makefile appelé est le suivant :
```Makefile
# Variables pour la compilation
C++ = g++
CFLAGS = $(shell pkg-config --cflags armadillo) -Wall -Werror -g -O2
LDLIBS = $(shell pkg-config --libs armadillo) -llapack -lblas
SDIR = src
HDIR = lib
BDIR = bin
TDIR = test
OUTDIR = output
TARGET = $(BDIR)/main
TEST_TARGET = $(BDIR)/test_runner

# Variables pour Doxygen
DOXYGEN = doxygen
DOXYFILE = doc/Doxyfile
DOCDIR = doc/html

# Sources, objets, et fichiers de test
SRCS = $(wildcard $(SDIR)/*.cpp)
OBJS = $(patsubst $(SDIR)/%.cpp, $(BDIR)/%.o, $(filter-out $(SDIR)/main.cpp, $(SRCS)))
ALL_OBJS = $(wildcard $(BDIR)/*)
TEST_HEADERS = $(wildcard $(TDIR)/test_*.h)
ALL_OBJS = $(wildcard $(BDIR)/*.o)

RUNNER_CPP = $(BDIR)/runner.cpp
RUNNER_OBJ = $(BDIR)/runner.o

# Compilation principale
all: $(TARGET)

$(TARGET): $(OBJS) $(BDIR)/main.o | $(BDIR)
	$(C++) $(OBJS) $(BDIR)/main.o -o $(TARGET) $(LDLIBS)

$(BDIR)/main.o: $(SDIR)/main.cpp
	$(C++) $(CFLAGS) -c $(SDIR)/main.cpp -o $@
```

---
class: middle

# II - Makefile

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

```Makefile
# Génération et compilation des tests avec CxxTest
$(RUNNER_CPP): $(TEST_HEADERS)
	cxxtestgen --error-printer -o $(RUNNER_CPP) $(TEST_HEADERS)

$(RUNNER_OBJ): $(RUNNER_CPP)
	$(C++) $(CFLAGS) -c $(RUNNER_CPP) -o $@

tests: $(TEST_TARGET)

$(TEST_TARGET): $(RUNNER_OBJ) $(OBJS) | $(BDIR)
	$(C++) $(RUNNER_OBJ) $(OBJS) -o $(TEST_TARGET) $(LDLIBS)

$(BDIR)/%.o: $(SDIR)/%.cpp $(HDIR)/%.h
	$(C++) $(CFLAGS) -c $< -o $@

$(BDIR):
	mkdir -p $(BDIR)

# Génération de la documentation avec Doxygen
.PHONY: doc
doc:
	@echo "Génération de la documentation avec Doxygen..."
	$(DOXYGEN) $(DOXYFILE)
	@echo "La documentation HTML a été générée dans $(DOCDIR)"

# Nettoyage des fichiers objets, binaires, et documentation
.PHONY: clean
clean:
	rm -f $(OBJS) $(RUNNER_OBJ) $(TARGET) $(TEST_TARGET) $(RUNNER_CPP) $(BDIR)/main.o $(ALL_OBJS)
	rm -rf $(DOCDIR)
	rm -f $(wildcard $(OUTDIR)/*)
```
---
class: middle

# II - Implémentation - Fonctionnement du Main  

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]


#### Utilisation du main
Dans le main, on va lire dans le fichier /input/input.txt afin de récupérer des données que l'on va utiliser dans le projet
Puis on va commencer par créer les vecteurs z et r.

```cpp
int main()
{
    float z_min, z_max, r_min, r_max;
    int N_z, N_r;

    read_input_file(&z_min, &z_max, &N_z, &r_min, &r_max, &N_r);

    // Creats a vector of z
    vec z_vec = arma::linspace(z_min, z_max, N_z);

    // Creats a vector of r
    vec r_vec = arma::linspace(r_min, r_max, N_r);
```

---
class: middle

# II - Implémentation - Fonctionnement du Main (2)

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

Une fois les vecteurs crées on peut faire appel aux différents algorithmes utilisés pour calculer les solutions,
Nous en possédons 4. Pour observer le temps on fait appel à clock0.tic() et clock0.toc(); 

### Suite du main :

```cpp
Density density;
arma::mat local_density = arma::zeros(z_vec.n_elem, r_vec.n_elem);
// === Version 0 ===
cout << "Si c'est trop long, commentez l'appel à la fonction naive ou réduire le nombre de points" << endl;
arma::wall_clock clock0;
clock0.tic();
local_density = density.calcDensityNaive(z_vec, r_vec);
double time0 = clock0.toc();
cout << "Naive algo : " << time0 << " [s]" << endl;

// === Version 1 ===
arma::wall_clock clock1;
clock1.tic();
local_density = density.calcDensityOpti_1(z_vec, r_vec);
double time1 = clock1.toc();
cout << "Algo opti 1: " << time1 << " [s]" << endl;

// === Version 2 ===
arma::wall_clock clock2;
clock2.tic();
local_density = density.calcDensityOpti_2(z_vec, r_vec);
double time2 = clock2.toc();
cout << "Algo opti 2: " << time2 << " [s]" << endl;

// === Version 3 ===
arma::wall_clock clock3;
clock3.tic();
local_density = density.calcDensityOpti_3(z_vec, r_vec);
double time3 = clock3.toc();
cout << "Algo opti 3: " << time3 << " [s]" << endl;

arma::mat res = local_density;
```
---
class: middle
# II - Implémentation - Modèle naïf
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

Pour le modèle naïf on utilise la formule donnée dans le cours qui suit : 
`$$
\rho(\mathbf{r})
\equiv
\sum_{a,b} \rho_{ab}\psi_a(\mathbf{r})\psi^*_b(\mathbf{r})
=
\sum_{{m_a, n_a, n_{za}} \atop {m_b,n_b,n_{zb}}}\rho_{m_a, n_a, n_{za}, m_b,n_b,n_{zb}}\psi_{m_a,n_a,n_{za}}(\mathbf{r})\psi^*_{m_b,n_b,n_{zb}}(\mathbf{r})
$$`

```cpp 
arma::mat Density::calcDensityNaive(arma::vec zVals, arma::vec rVals)
{
    arma::uword nbZ = zVals.n_elem;
    arma::uword nbR = rVals.n_elem;
    Basis basis(1.935801664793151, 2.829683956491218, 14, 1.3);
    // Initialize the result matrix to zero
    arma::mat result = arma::zeros(nbZ, nbR);
	// === Version 0 ===
	uint a = 0;
	for (int ma = 0; ma < basis.mMax; ++ma) {
		for (int na = 0; na < basis.nMax(ma); ++na) {
			for (int n_za = 0; n_za < basis.n_zMax(ma, na); ++n_za) {
				uint b = 0;
				for (int mb = 0; mb < basis.mMax; ++mb) {
					for (int nb = 0; nb < basis.nMax(mb); ++nb) {
						for (int n_zb = 0; n_zb < basis.n_zMax(mb, nb); ++n_zb) {
							// Evaluate the basis functions at all points (zVals, rVals)
							arma::mat psiA = basis.psi(ma, na, n_za, zVals, rVals);
							arma::mat psiB = basis.psi(mb, nb, n_zb, zVals, rVals);
							// Accumulate the result
							result += psiA % psiB * rho(a, b);
							b++  ;
						}
					}
				}
				a++;
			}
		}
	}
	return result;
}
```
---
class: middle 
# II - Implémentation - Modèle naïf (2)
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Nous avons besoin des paramètres de la troncature suivants : 
`$$
\nu(i) \equiv (N+2).Q^\frac{2}{3}+\frac{1}{2}-i.Q
$$`
`$$
m^\textrm{max} \equiv \textrm{sup}\left\{i:\nu(i)\ge 1\right\}.
$$`

``` cpp
Basis::Basis(double _br, double _bz, int _N, double _Q) : br(_br), bz(_bz), N(_N), Q(_Q)
{
    // mMax must be initialized correctly
    mMax = _N;

    // Computing nMax values
    nMax.set_size(mMax);
    for (int m = 0; m < mMax; m++)
    {
        nMax(m) = 0.5 * (mMax - m - 1) + 1;
    }

    // Lambda function to compute mu
    auto mu = [&](int i) -> double // Utilisation de double pour mu
    {
        return (_N + 2) * pow(_Q, 2.0 / 3.0) + 0.5 - i * _Q;
    };

    // Computing n_zMax values
    n_zMax.set_size(mMax, nMax.max());
    for (int m = 0; m < mMax; m++)
    {
        for (int n = 0; n < nMax(m); n++)
        {
            n_zMax(m, n) = mu(m + 2 * n + 1);
        }
    }
}
```


---
class: middle
# II - Implémentation - Modèle naïf (3)

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

Or, nous avons besoin des valeurs des vecteurs z et r obtenus à  l'aide des formules suivantes :
`$$
Z(z, n_z)
\equiv
         \frac{1}{\sqrt{b_z}}
         \frac{1}{\sqrt{2^{n_z} \sqrt{\pi}n_z!}}
         e^{-\frac{z^2}{2b_z^2}}H_{n_z}\left(\frac{z}{b_z}\right)
$$`
```cpp
arma::vec Basis::zPart(arma::vec zvec, int nz)
{
    Poly poly;
    poly.calcHermite(nz, zvec / bz);

    double c = 1 / (sqrt(bz) * sqrt(pow(2, nz) * tgamma(nz + 1) * sqrt(M_PI)));
    arma::vec exp_part = arma::exp(-0.5 * arma::pow(zvec / bz, 2.0));

    return c * exp_part % poly.hermite(nz);
}
```
et 
`$$
R(r_\perp, m, n)
         \equiv
         \frac{1}{b_{\perp}\sqrt{\pi}}
         \sqrt{\frac{n!}{(n+|m|)!}}
         e^{-\frac{r_{\perp}^2}{2b_{\perp}^2}}
         \left(\frac{r_{\perp}}{b_{\perp}}\right)^{|m|}
         L_n^{|m|}\left(\frac{r_{\perp}^2}{b_{\perp}^2}\right).
$$`
```cpp
arma::vec Basis::rPart(arma::vec rvec, int m, int n)
{
    double am = abs(m);

    Poly poly;
    poly.calcLaguerre(am, n, arma::pow(rvec / br, 2.0));

    double c = (1 / (br * sqrt(M_PI))) * sqrt(tgamma(n + 1) / tgamma(n + am + 1));
    arma::vec exp_part = arma::exp(-0.5 * arma::pow(rvec / br, 2.0));

    return c * exp_part % arma::pow(rvec / br, am) % poly.laguerre(am, n);
}
```
---

class: middle

# II - Implémentation - Modèles Optimisés

## 1ère optimisation : symétrie

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Pour optimiser le programme, plusieurs points peuvent être améliorés. 
Tout d'abord on peut voir que la matrice rho est symétrique 

```cpp
// === Version 1 : rho is symetric ===
uint a = 0;
for (int ma = 0; ma < basis.mMax; ++ma) {
    for (int na = 0; na < basis.nMax(ma); ++na) {
        for (int n_za = 0; n_za < basis.n_zMax(ma, na); ++n_za) {
            uint b = a; // Start b from a (symmetry exploitation)
            for (int mb = ma; mb < basis.mMax; ++mb) {
                for (int nb = (mb == ma ? na : 0); nb < basis.nMax(mb); ++nb) {
                    for (int n_zb = (mb == ma && nb == na ? n_za : 0); n_zb < basis.n_zMax(mb, nb); ++n_zb) {
                        // Evaluate psi_b from cache
                        arma::mat psiA = basis.psi(ma, na, n_za, zVals, rVals);
                        arma::mat psiB = basis.psi(mb, nb, n_zb, zVals, rVals);

                        // Symmetry consideration
                        if (a == b) {
                            result += psiA % psiB * rho(a, b);
                        } else {
                            result += 2 * (psiA % psiB) * rho(a, b);
                        }
                        b++;
                    }
                }
            }
            a++;
        }
    }
}
return result;
}
```
---
class: middle

# II - Implémentation - Modèles Optimisés (2)
## 2ème optimisation : m-diagonalité
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
En effet on remarque que la matrice rho est également m-diagonale

```cpp
// === Version 2 : rho is m-diagonal === 
uint a = 0;
for (int ma = 0; ma < basis.mMax; ++ma) {
    for (int na = 0; na < basis.nMax(ma); ++na) {
        for (int n_za = 0; n_za < basis.n_zMax(ma, na); ++n_za) {
            uint b = a; // Start b from a (symmetry exploitation)
            for (int nb = na ; nb < basis.nMax(ma); ++nb) {
                for (int n_zb = (nb == na ? n_za : 0); n_zb < basis.n_zMax(ma, nb); ++n_zb) {
                    arma::mat psiA = basis.psi(ma, na, n_za, zVals, rVals);
                    arma::mat psiB = basis.psi(ma, nb, n_zb, zVals, rVals);

                    // Symmetry consideration
                    if (a == b) {
                        result += psiA % psiB * rho(a, b);
                    } else {
                        result += 2 * (psiA % psiB) * rho(a, b);
                    }
                    b++;
                }
            }
            a++;
        }
    }
}
return result;
```

---
class: middle

# II - Implémentation - Modèles Optimisés (3)

## 3ème optimisation : Meilleurs parcours de boucle

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Les boucles peuvent être parcourus de différentes manières et peuvent être mises plus profondément dans le code 
pour minimiser leur impact sur le reste des calculs
```cpp
// === Version 3 : moving loops as deep as possible ===
uint a = 0;
for (int ma = 0; ma < basis.mMax; ++ma) {
    for (int na = 0; na < basis.nMax(ma); ++na) {
        for (int n_za = 0; n_za < basis.n_zMax(ma, na); ++n_za) {
            arma::mat psiA = basis.psi(ma, na, n_za, zVals, rVals);

            // Diagonal contributions (a == b)
            uint b = a;
            result += psiA % psiA * rho(a, b);

            // Non-diagonal contributions (a < b)
            b = a + 1; // Start at the next index
            for (int nb = na; nb < basis.nMax(ma); ++nb) {
                for (int n_zb = (nb == na ? n_za + 1 : 0); n_zb < basis.n_zMax(ma, nb); ++n_zb) {
                    arma::mat psiB = basis.psi(ma, nb, n_zb, zVals, rVals);

                    // Accumulate the symmetric terms
                    result += 2 * (psiA % psiB) * rho(a, b);
                    b++;
                }
            }
            a++;
        }
    }
}
return result;
```

---
class: middle
# II - Implémentation - Comparaison des temps obtenus
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Après tests effectifs de ces 4 versions de l'algorithme, voici les résultats que l'on peut en tirer :


```

----------Execution du programme principal----------
Reading input.txt file
Si c'est trop long, commentez l'appel à la fonction naive ou réduire le nombre de points
Naive algo : 0.987681 [s]
Algo opti 1: 0.508909 [s]
Algo opti 2: 0.0615764 [s]
Algo opti 3: 0.032946 [s]
Fichier matrix.csv créé
```


---
class: middle
#III - Tests unitaires

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Une batterie de tests unitaires étaient à vérifier 

```cpp
void testBasisTruncation()
{
    // Mandatory test #01 - Basis truncation

    //     br = 1.935801664793151, bz = 2.829683956491218, N = 14, Q = 1.3
    Basis basis(1.935801664793151,      2.829683956491218,     14,     1.3);

    TS_ASSERT_EQUALS(basis.mMax, 14);

    arma::ivec nMax = {7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1};

    TS_ASSERT((basis.nMax - nMax).is_zero());

    arma::imat n_zMax = {{18, 15, 13, 10, 7, 5, 2}, 
                        {16, 14, 11,  9, 6, 3, 1}, 
                        {15, 13, 10,  7, 5, 2, 0}, 
                        {14, 11,  9,  6, 3, 1, 0}, 
                        {13, 10,  7,  5, 2, 0, 0}, 
                        {11,  9,  6,  3, 1, 0, 0}, 
                        {10,  7,  5,  2, 0, 0, 0}, 
                        { 9,  6,  3,  1, 0, 0, 0}, 
                        { 7,  5,  2,  0, 0, 0, 0}, 
                        { 6,  3,  1,  0, 0, 0, 0}, 
                        { 5,  2,  0,  0, 0, 0, 0}, 
                        { 3,  1,  0,  0, 0, 0, 0}, 
                        { 2,  0,  0,  0, 0, 0, 0}, 
                        { 1,  0,  0,  0, 0, 0, 0}};

    // check if matrices are equal
    TS_ASSERT((basis.n_zMax - n_zMax).is_zero());
}
```


---
class: middle
#III - Tests unitaires

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Une batterie de tests unitaires étaient à vérifier 

```cpp
void testBasisRFuncition()
{
    // Mandatory test #02 - Basis r-functions

    //     br = 1.935801664793151, bz = 2.829683956491218, N = 14, Q = 1.3
    Basis basis(1.935801664793151,      2.829683956491218,     14,     1.3);

    arma::vec r = {3.1, 2.3, 1.0, 0.0, 0.1, 4.3, 9.2, 13.7};

    arma::vec res00 = { 8.08521235111303e-02,
                        1.43887615825118e-01,
                        2.55045100912706e-01,
                        2.91450097294984e-01,
                        2.91061479407116e-01,
                        2.47240792330589e-02,
                        3.63004153921473e-06,
                        3.87659726026123e-12};

    TS_ASSERT_DELTA(arma::norm(basis.rPart(r, 0, 0) - res00), 0.0, 1e-15);

    arma::vec res82 = { 5.87858442372438e-02,
                        1.35240488413384e-02,
                        4.06810074575519e-05,
                        0.00000000000000e+00,
                        4.92817669085478e-13,
                        8.52011998934850e-02,
                        5.20525909328609e-02,
                        1.44615166152252e-05};
                        
    TS_ASSERT_DELTA(arma::norm(basis.rPart(r, 8, 2) - res82), 0.0, 1e-15);
}
```

---
class: middle
#III - Tests unitaires

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Une batterie de tests unitaires étaient à vérifier 

```cpp
void testBasisZFunction()
{
    // Mandatory test #03 - Basis z-functions

    //     br = 1.935801664793151, bz = 2.829683956491218, N = 14, Q = 1.3
    Basis basis(1.935801664793151,      2.829683956491218,     14,     1.3);

    arma::vec z = {-10.1, -8.4, -1.0, 0.0, 0.1, 4.3, 9.2, 13.7};

    arma::vec res00 = { 7.64546544834383e-04,
                        5.44886272162148e-03,
                        4.19492564268520e-01,
                        4.46522724110539e-01,
                        4.46243982300708e-01,
                        1.40736821086932e-01,
                        2.26186220733178e-03,
                        3.62929640195959e-06};

    TS_ASSERT_DELTA(arma::norm(basis.zPart(z, 0) - res00), 0.0, 1e-15);

    arma::vec res15 = { -9.48674551049192e-02,
                        -1.40338701953237e-03,
                         1.85620628040096e-01,
                        -0.00000000000000e+00,
                        -3.93028470685214e-02,
                        -1.79526868763440e-01,
                         2.15604096600475e-01,
                         2.44977220882127e-01};

    TS_ASSERT_DELTA(arma::norm(basis.zPart(z, 15) - res15), 0.0, 1e-15);
}
```
---
class: middle
#III - Tests unitaires

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Une batterie de tests unitaires étaient à vérifier 

```cpp
void testDensity()
{
    Density density;
    TS_ASSERT_EQUALS(density.rho.n_cols, 374);
}

void testCalcDensity()
{
    Density density;

    // Given: A set of z and r values
    arma::vec zVals = arma::linspace(-500, 500, 100); // Example z-values
    arma::vec rVals = arma::linspace(0, 500, 100);  // Example r-values

    // When: Calculating the density
    arma::mat densityResult = density.calcDensityOpti_3(zVals, rVals);
    arma::mat densityExpected = density.calcDensityOpti_4(zVals, rVals);

    // Check that the result is not empty
    TS_ASSERT(densityResult.is_empty() == false);

    // Then: Check the dimensions of the result
    TS_ASSERT_EQUALS(densityResult.n_rows, zVals.n_elem);
    TS_ASSERT_EQUALS(densityResult.n_cols, rVals.n_elem);

    TS_ASSERT_DELTA(arma::norm(densityResult - densityExpected), 0.0, 1e-15);
}
```
---
class: middle
#III - Tests unitaires

.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
Une batterie de tests unitaires étaient à vérifier 

```cpp
void testPoly()
{
    // Mandatory test #00 - Hermite and Laguerre polynomials
    Poly poly;

    arma::vec zVals, calcVals, targetVals;

    zVals = {-3.1, -2.3, -1.0, -0.3, 0.1, 4.3, 9.2, 13.7};
    poly.calcHermite(6, zVals); // compute Hermite polynomials for n in {0 ... 5}

    calcVals   = poly.hermite(4); // n = 4
    targetVals = {  1.02835360e+03,  2.05825600e+02, -2.00000000e+01,  7.80960000e+00,
                    1.15216000e+01,  4.59456160e+03,  1.10572154e+05,  5.54643458e+05};
    TS_ASSERT_DELTA(arma::norm(calcVals / targetVals - 1.0), 0.0, 1e-08);

    calcVals   = poly.hermite(5); // n = 5
    targetVals = { -4.76676832e+03, -3.88909760e+02,  8.00000000e+00, -3.17577600e+01,
                    1.18403200e+01,  3.48375818e+04,  1.98557479e+06,  1.50339793e+07};
    TS_ASSERT_DELTA(arma::norm(calcVals / targetVals - 1.0), 0.0, 1e-08);

    zVals = {0.1, 0.3, 1.2, 1.8, 2.0, 2.5, 7.1, 11.1};
    poly.calcLaguerre(6, 4, zVals); // compute generalized Laguerre polynomials for m in {0 ... 5} and n in {0 ... 3}
    
    calcVals   = poly.laguerre(4, 2); // m = 4, n = 2
    targetVals = {  14.405,  13.245,  8.52 ,  5.82 ,  5.,  3.125,  -2.395,  10.005};
    TS_ASSERT_DELTA(arma::norm(calcVals / targetVals - 1.0), 0.0, 1e-08);

    calcVals   = poly.laguerre(5, 3); // m = 5, n = 3

    targetVals = { 53.23983333,  47.95550000,  27.87200000,  17.5880,
                14.66666667,   8.39583333,  -0.81183333,  10.1015};
    TS_ASSERT_DELTA(arma::norm(calcVals / targetVals - 1.0), 0.0, 1e-08);
}
```
---
class: middle
# III - Représentation 2D

Pour représenter les valeurs 2D, on va utiliser python et créer une heatmap 
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
```py

# Convertir en entier ou float si nécessaire
try:
    value = int(value)
except ValueError:
    try:
        value = float(value)
    except ValueError:
        pass  # Garde une chaîne de caractères si non convertible

# Assigner directement aux variables
if key == "Valeur de z_min":
    z_min = value
elif key == "Valeur de z_max":
    z_max = value
elif key == "Nombre de points Z":
    nombre_points_z = value
elif key == "Valeur de r_min":
    r_min = value
elif key == "Valeur de r_max":
    r_max = value
elif key == "Nombre de points R":
    nombre_points_r = value

# Création de la heatmap
plt.figure(figsize=(10, 8))
plt.imshow(matrix, extent=[z_min, z_max, r_min, r_max], origin="lower", cmap="viridis", aspect="auto")
plt.colorbar(label="Valeur de densité")  # Ajouter une barre de couleurs
plt.title("Densité calculée sur la grille (Z, R)")
plt.xlabel("Z (distance axiale)")
plt.ylabel("R (distance radiale)")

```
---
class: middle 
# III - Représentation 2D - Résultat 
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
### On obtient le résultat suivant :

.hcenter.shadow.w50[![](../output/heatmap_density_visualization.png)]



---
class: middle
# III - Représentation 3D - matrice vers cube
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

### Pour pouvoir effectuer la représentation 3D, nous avons besoin de transformer la matrice 2D en cube 3D. 
Sachant que l'on a une symétrie autour de l'axe de rotation, on peut transformer la matrice ainsi :

```cpp
arma::cube matrixToCube(const arma::mat& matrix)
{
    arma::cube cubeResult = arma::zeros(32, 32, 64);
    //cout << "matrix size : " << matrix.n_rows << "*" << matrix.n_cols << endl;
    for (int x = 0; x < 32; x++)
    {
        for (int y = 0; y < 32; y++)
        {
            int distance = static_cast<int>(std::sqrt(std::pow(x - 32, 2) + std::pow(y - 32, 2)));
            for (int z = 0; z < 64; z++)
            {
                // on fait la moyenne entre 2 points
                if (distance < 32)
                {
                    if (distance <= 0)
                    {cubeResult(x, y, z) = matrix(z, 0);
                    }
                    else
                    {cubeResult(x, y, z) = matrix(z, distance);
                    }
                }
                else
                {cubeResult(x, y, z) = 0;
                }
            }
        }
    }
	return cubeResult;
}
```
---
class: middle
# III - Représentation 3D - Transformation en DF3 et povray
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

##### Une fois le cube 3D des valeurs obtenu on peut utiliser les fonctions de transformation en DF3 le code povray donné pour représenter la densité de probabilité
```cpp

std::string cubeToDf3(const arma::cube &cube)
{
	std::stringstream ss(std::stringstream::out | std::stringstream::binary);
	int nx = cube.n_rows;
	int ny = cube.n_cols;
	int nz = cube.n_slices;
	ss.put(nx >> 8);
	ss.put(nx & 0xff);
	ss.put(ny >> 8);
	ss.put(ny & 0xff);
	ss.put(nz >> 8);
	ss.put(nz & 0xff);
	double theMin = 0.0;
	double theMax = cube.max();
	for (uint k = 0; k < cube.n_slices; k++)
	{
		for (uint j = 0; j < cube.n_cols; j++)
		{
			for (uint i = 0; i < cube.n_rows; i++)
			{
				uint v = 255 * (fabs(cube(i, j, k)) - theMin) / (theMax - theMin);
				ss.put(v);
			}
		}
	}
	return ss.str();
}

```

---
class: middle
# III - Représentation 3D - Résultat
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]
.hcenter.shadow.w50[![](../src/visu.png )]

---
class: middle
# III - Conclusion 
.footnote[E.Onal, S. Darnault, A. Marquis - ENSIIE - 2025]

### L'optimisation des algortihmes a permis un gain de facteur compris entre 30 et 35 par rapport à l'algorithme naïf.









    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/katex.min.js"></script>
    <script src="core/javascript/auto-render.min.js"></script>
    <script src="core/javascript/emojify.js"></script>
    <script src="core/javascript/mermaid.js"></script>
    <script src="core/javascript/term.js"></script>
    <script src="core/javascript/jquery-2.1.1.min.js"></script>
    <script src="core/javascript/extend-jquery.js"></script>
    <script src="core/javascript/cinescript.js"></script>
    <script src="core/javascript/gitgraph.js"></script>
    <script>

        // === Remark.js initialization ===
        var slideshow = remark.create({
            highlightStyle: 'monokai',
            countIncrementalSlides: false,
            highlightLines: false
        });

        // === Mermaid.js initialization ===
        mermaid.initialize({
            startOnLoad: false,
            cloneCssStyles: false,
            flowchart: {
                height: 50
            },
            sequenceDiagram: {
                width: 110,
                height: 30
            }
        });

        function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i = 0; i < diagrams.length; i++) {
                if (diagrams[i].offsetWidth > 0) {
                    mermaid.init(undefined, diagrams[i]);
                }
            }
        }

        slideshow.on('afterShowSlide', initMermaid);
        initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);


        // === Emojify.js initialization ===
        emojify.run();

        // === Cinescript initialization ===
        $(document).ready(init_cinescripts);

        renderMathInElement(document.body, {
            delimiters: [{ left: "$$", right: "$$", display: true }, {
                left: "\\(",
                right: "\\)",
                display: false
            }], ignoredTags: []
        });

    </script>
</body>

</html>